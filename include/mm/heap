%%
% MMIX support library for various purposes.
%
% Copyright (C) 2013-2014 Matthias Maier <tamiko@kyomu.43-1.org>
%
% Permission is hereby granted, free of charge, to any person
% obtaining a copy of this software and associated documentation files
% (the "Software"), to deal in the Software without restriction,
% including without limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of the Software,
% and to permit persons to whom the Software is furnished to do so,
% subject to the following conditions:
%
% The above copyright notice and this permission notice shall be
% included in all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
% EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
% NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
% BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
% ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.
%%

%
% :MM:Heap:
%
% Routines for dynamic memory allocation/deallocation and related
% tasks on the heap. The implementation of the heap is platfrom
% dependend.
%
% mmixal and GNU as on mmix-sim:
%   The heap will be organized as memory blocks inside the pool
%   segment of the executable. This needs some cooperation from the
%   user: The convention (as defined by the mmix-sim documentation) is
%   that M_8[:Pool_Segment] points to the first unallocated region
%   within the pool adress space. User programs utilizing address
%   space from the pool segment must obey this rule by 'allocating'
%   memory by modifying M_8[:Pool_Segment] appropriately.
%
% - Stable ABI, fully implemented -
%
% All subroutines come in two variants. The first variant, without a
% trailing 'J', will terminate the program with an error message, the
% second variant (with a trailing 'J'), will jump to :rJ+#4 on succes
% and to :rJ+#0 on failure, and can be used to implement customized
% error handling. An example:
%           % Try to allocate a block of memory:
%           SET         $1,[...]
%           PUSHJ       $0,:MM:Heap:AllocJ
%           JMP         1F
%           [...] % Allocation was successful, continue normally.
%
%    1H     [...] % Allocation failed, error handling.
%
% Subroutines that have at most one argument and one return parameter
% come also in a variant with a trailing 'G' which indicates that
% values are passed through the temporary general register $255. An
% example:
%           % Try to allocate a block of memory:
%           SET         $255,[...]
%           PUSHJ       $255,:MM:Heap:AllocG
%                       % Address of allocated memory in $255
%
% This header file defines:
%   :MM:Heap:Alloc (AllocJ, AllocG)
%   :MM:Heap:Dealloc (DeallocJ, DeallocG)
%   :MM:Heap:Realloc (ReallocJ)
%   :MM:Heap:Valid (ValidJ, ValidG)
%   :MM:Heap:Size (SizeJ, SizeG)
%   :MM:Heap:Copy (CopyJ)
%   :MM:Heap:Set (SetJ, SetG)
%   :MM:Heap:Zero (ZeroJ, ZeroG)
%

#ifndef MM_HEAP
#define MM_HEAP

#ifdef __MMIXAL
#define __MM_INTERNAL
#include "../../src/__mmixal_init.mmh"
#include "../../src/__rand.mmh"
#include "../../src/__mem.mmh"
#include "../../src/__heap.mmh"
#undef __MM_INTERNAL
#endif

            PREFIX      :MM:

%%
% :MM:Heap:Alloc
%   Allocate a continuous block of memory of size arg0. The returned
%   address is octa aligned (and != #0). If allocation fails, the
%   program is terminated with an error message.
%
%   PUSHJ:
%   arg0 - requested size (in bytes)
%   retm - pointer to allocated memory
%
% :MM:Heap:AllocJ
%   This variant returns to :rJ+#4 on success and to :rJ+#0 (with no
%   return value) on failure instead of throwing an error message.
%   Same calling sequence as above.
%
% :MM:Heap:AllocG
%   This variant passes arg0 and retm through the general register $255.
%
Heap:Alloc  IS          :MM:__HEAP:Alloc
Heap:AllocJ IS          :MM:__HEAP:AllocJ
Heap:AllocG IS          :MM:__HEAP:AllocG

%%
% :MM:Heap:Dealloc
%   Deallocate a previously allocated block of memory pointed to by
%   pointer arg0. The memory region must be previously allocated with
%   :MM:Heap:Alloc, and must not be already freed. If arg0 is an
%   invalid pointer the program is terminated with an error message.
%
%   PUSHJ:
%   arg0 - pointer to allocated memory
%   no return value
%
%   Precondition:
%   arg0 must point to a valid, not yet freed memory region previously
%   allocated with :MM:Heap:Alloc
%
% :MM:Heap:DeallocJ
%   This variant returns to :rJ+#4 on success and to :rJ+#0 on failure
%   instead of throwing an error message. Same calling sequence as
%   above.
%
% :MM:Heap:AllocG
%   This variant passes arg0 through the general register $255. $255 will
%   be set to #0 on return
%
Heap:Dealloc  IS        :MM:__HEAP:Dealloc
Heap:DeallocJ IS        :MM:__HEAP:DeallocJ
Heap:DeallocG IS        :MM:__HEAP:DeallocG

%%
% :MM:Heap:Realloc
%   Allocate a new block of memory of arg1 bytes, copy the memory
%   pointed to by arg0 into it up to min(size(arg0),arg1) bytes.
%   Deallocate the memory region pointed to by arg0 and return the
%   pointer to the new memory region.
%
%   PUSHJ:
%   arg0 - pointer to  memory region
%   arg1 - requested size (in bytes)
%   retm - pointer to allocated memory
%
%   Precondition:
%   arg0 must point to a valid, not yet freed memory region previously
%   allocated with :MM:Heap:Alloc.
%
% :MM:Heap:ReallocJ
%   This variant returns to :rJ+#4 on success and to :rJ+#0 (with no
%   return value) on failure instead of throwing an error message.
%   Same calling sequence as above. In case of error, the memory block
%   at arg0 is guaranteed to be still allocated.
%
Heap:Realloc  IS        :MM:__HEAP:Realloc
Heap:ReallocJ IS        :MM:__HEAP:ReallocJ

%%
% :MM:Heap:Valid
%   Return whether arg0 points to a bunch of allocated memory. 0
%   indicates a valid pointer, -1 an invalid one.
%
%   PUSHJ:
%   arg0 - pointer to allocated memory
%   retm - 0 indicating a valid pointer, -1 otherwise
%
% :MM:Heap:ValidJ
%   This variant returns to :rJ+#4 if arg0 is a valid pointer and to
%   :rJ+#0 on failure. No return value.
%
%   PUSHJ:
%   arg0 - pointer to allocated memory
%   no return value
%
% :MM:Heap:ValidG
%   This variant passes retm through the general register $255.
%
Heap:Valid  IS          :MM:__HEAP:Valid
Heap:ValidJ IS          :MM:__HEAP:ValidJ
Heap:ValidG IS          :MM:__HEAP:ValidG

%%
% :MM:Heap:Size
%   Return the size of the allocated memory pointed to by arg0. If
%   arg0 is an invalid pointer the program is terminated with an error
%   message.
%
%   PUSHJ:
%   arg0 - pointer to allocated memory
%   retm - size of the allocated memory
%
%   Precondition:
%   arg0 must point to a valid, not yet freed memory region previously
%   allocated with :MM:Heap:Alloc
%
% :MM:Heap:SizeJ
%   This variant returns to :rJ+#4 on success and to :rJ+#0 on failure
%   instead of throwing an error message. Same calling sequence as
%   above.
%
% :MM:Heap:SizeG
%   This variant passes arg0 and retm through the general register $255.
%
Heap:Size   IS          :MM:__HEAP:Size
Heap:SizeJ  IS          :MM:__HEAP:SizeJ
Heap:SizeG  IS          :MM:__HEAP:SizeG

%%
% :MM:Heap:Copy
%   Does an octawise copy of the memory region pointed to by arg0 to
%   the memory region pointed to by arg1 of exactly
%   min(size(arg0),size(arg1)) bytes. arg0 and arg1 must point to the
%   beginning of valid, not yet freed memory regions previously
%   allocated with :MM:Heap:Alloc. For raw memory regions use
%   :MM:Heap:Copy instead.
%
%   PUSHJ:
%   arg0 - pointer to source memory
%   arg1 - pointer to destination memory
%   no return value
%
%   Precondition:
%   arg0 and arg1 must point to valid, not yet freed memory regions
%   previously allocated with :MM:Heap:Alloc.
%
% :MM:Heap:CopyJ
%   This variant returns to :rJ+#4 on success and to :rJ+#0 on failure
%   instead of throwing an error message. Same calling sequence as
%   above.
%
Heap:Copy   IS          :MM:__HEAP:Copy
Heap:CopyJ  IS          :MM:__HEAP:CopyJ

%%
% :MM:Heap:Set
%   Sets the entire contents of the memory block pointed to by arg0 to
%   the least significant bit of arg1. arg0 must point to the
%   beginning of valid, not yet freed memory regions previously
%   allocated with :MM:Heap:Alloc. For raw memory regions use
%   :MM:Mem:Set (SetJ) instead.
%
%   PUSHJ:
%   arg0 - pointer to memory block
%   arg1 - byte template
%   no return value
%
%   Precondition:
%   arg0 must point to a valid, not yet freed memory region previously
%   allocated with :MM:Heap:Alloc.
%
% :MM:Heap:SetJ
%   This variant returns to :rJ+#4 on success and to :rJ+#0 on failure
%   instead of throwing an error message. Same calling sequence as
%   above.
%
Heap:Set    IS          :MM:__HEAP:Set
Heap:SetJ   IS          :MM:__HEAP:SetJ

%%
% :MM:Heap:Zero
%   This subroutine works on memory regions allocated by Heap:Alloc.
%   It sets the entire contents of the memory block pointed to by arg0
%   to zero. arg0 must point to the beginning of a valid, not yet
%   freed memory regions previously allocated with :MM:Heap:Alloc. For
%   raw memory regions use :MM:Mem:Zero (ZeroJ) instead.
%
%   PUSHJ:
%   arg0 - pointer to memory block
%   no return value
%
%   Precondition:
%   arg0 must point to a valid, not yet freed memory region previously
%   allocated with :MM:Heap:Alloc.
%
% :MM:Heap:ZeroJ
%   This variant returns to :rJ+#4 on success and to :rJ+#0 on failure
%   instead of throwing an error message. Same calling sequence as
%   above.
%
% :MM:Heap:ZeroG
%   This variant passes arg0 through the general register $255.
%
Heap:Zero   IS          :MM:__HEAP:Zero
Heap:ZeroJ  IS          :MM:__HEAP:ZeroJ
Heap:ZeroG  IS          :MM:__HEAP:ZeroG

%%
% :MM:Heap:Rand
%   This subroutine works on memory regions allocated by Heap:Alloc.
%   It overwrites the entire contents of the memory block pointed to
%   by arg0 with random data. arg0 must point to the beginning of a
%   valid, not yet freed memory regions previously allocated with
%   :MM:Heap:Alloc. For raw memory regions use :MM:Mem:Rand (RandJ)
%   instead.
%
%   This subroutine uses the prng implementation described in
%   rand.mmh.
%
%   PUSHJ:
%   arg0 - pointer to memory block
%   no return value
%
%   Precondition:
%   arg0 must point to a valid, not yet freed memory region previously
%   allocated with :MM:Heap:Alloc.
%
% :MM:Heap:RandJ
%   This variant returns to :rJ+#4 on success and to :rJ+#0 on failure
%   instead of throwing an error message. Same calling sequence as
%   above.
%
% :MM:Heap:RandG
%   This variant passes arg0 through the general register $255.
%
Heap:Rand   IS          :MM:__HEAP:Rand
Heap:RandJ  IS          :MM:__HEAP:RandJ
Heap:RandG  IS          :MM:__HEAP:RandG

            PREFIX      :

#endif /* MM_HEAP */
